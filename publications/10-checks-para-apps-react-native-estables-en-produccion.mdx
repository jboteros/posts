---
title: 10 checks para apps React Native estables en producci√≥n
description: La mayor√≠a de los equipos celebran cuando el build pasa. Los equipos maduros celebran cuando el crash rate baja.
date: "2025-10-28"
published: true
language: es
---

![](/cover-images/10-checks-para-apps-react-native-estables-en-produccion.webp)

### üß† De conceptos a implementaci√≥n pr√°ctica

Si ya le√≠ste sobre las **5 pr√°cticas para apps estables**, probablemente te quedaste con ganas de ver m√°s detalles t√©cnicos. Aqu√≠ van los **10 checks concretos** que todo equipo de React Native deber√≠a validar antes de cada release.

Estos no son solo "buenas ideas", son **validaciones reales** con c√≥digo que puedes copiar y adaptar a tu proyecto hoy mismo.

---

## üìã Qu√© esperar de este checklist

Cada check incluye:

1. **üìñ Por qu√© importa** - El contexto no-t√©cnico para entender el valor
2. **üîß C√≥mo implementarlo** - C√≥digo espec√≠fico que puedes usar hoy
3. **‚úÖ Mejores pr√°cticas** - Consejos para evitar errores comunes

Este checklist est√° dise√±ado para ser tu **prerelease gate**: una lista de validaci√≥n que revisas antes de cada producci√≥n. No necesitas implementar todos de golpe‚Äîempieza con los primeros 3 y ve a√±adiendo los dem√°s gradualmente.

**Cada check reduce el riesgo de un incidente en producci√≥n.** Pi√©nsalo como una lista de seguridad para tu equipo: no es burocracia, es protecci√≥n.

---

## 1Ô∏è‚É£ Crash rate bajo control

### üìñ Por qu√© importa

Un crash es la peor experiencia que puede tener un usuario. Si tu app se cierra inesperadamente, no hay segunda oportunidad. El crash rate es tu indicador de salud m√°s importante: un **crash-free rate superior al 99,5%** deber√≠a ser tu meta en producci√≥n.

### üîß C√≥mo implementarlo

Usa herramientas como **Sentry**, **Firebase Crashlytics** o **Bugsnag** para monitorear cada release.

**Configuraci√≥n b√°sica con Sentry:**

```tsx
import * as Sentry from '@sentry/react-native';

Sentry.init({
  dsn: 'TU_DSN_AQUI',
  debug: __DEV__, // Solo en desarrollo
  tracesSampleRate: 1.0, // 100% de muestreo para sesiones
});

// Identifica el release y distribuci√≥n
flatMap(
  appInfo => {
    Sentry.setRelease(`${appInfo.version}-${appInfo.buildNumber}`);
    Sentry.setDist(appInfo.buildNumber);
  }
)(Application.nativeApplicationVersion)();

// Captura errores de JavaScript
Sentry.captureException(error, {
  tags: { section: 'Checkout' },
  extra: { userId: user.id },
});
```

**üö® Evita esto:**
- No captures TODO (filtra errores esperados)
- No guardes datos sensibles del usuario en logs
- No esperes a tener crashes para implementar monitoreo

**‚úÖ Mejores pr√°cticas:**
- Implementa `setRelease()` y `setDist()` para identificar qu√© versi√≥n introdujo un error
- Agrupa errores por sesi√≥n y usuario
- Configura alertas cuando el crash rate supere el 0.5%

---

## 2Ô∏è‚É£ Manejo de errores centralizado

### üìñ Por qu√© importa

Ya sabes que `addBreadcrumb()` y `captureException()` son esenciales en tus funciones cr√≠ticas (check #2 del art√≠culo anterior). Pero aqu√≠ hay algo m√°s: un error handler **global** que capture excepciones que ni siquiera sab√≠as que exist√≠an.

Los errores silenciosos son como termitas: no los ves hasta que rompen toda la estructura. Un manejo de errores centralizado captura TODAS las excepciones‚ÄîJavaScript, Native, promesas rechazadas y errores de red‚Äîpara que nada se te escape.

### üîß C√≥mo implementarlo

Define un `errorHandler` global que capture todos los tipos de errores.

**Instalaci√≥n de dependencias:**
```bash
npm install react-native-exception-handler @sentry/react-native
```

**Configuraci√≥n completa del error handler:**

```tsx
import { setJSExceptionHandler, setNativeExceptionHandler } from 'react-native-exception-handler';
import * as Sentry from '@sentry/react-native';

// Handler para errores de JavaScript
const errorHandler = (e: Error, isFatal: boolean) => {
  if (isFatal) {
    Sentry.captureException(e, {
      tags: { type: 'JSException' },
      level: 'fatal',
    });
    
    Alert.alert(
      'Error fatal',
      'Lo sentimos, la app necesita reiniciarse.',
      [{ text: 'Cerrar' }]
    );
  } else {
    // Error no fatal, solo loguear
    Sentry.captureException(e, {
      tags: { type: 'JSException' },
      level: 'error',
    });
  }
};

setJSExceptionHandler(errorHandler, true);

// Handler para errores nativos
setNativeExceptionHandler(exceptionString => {
  Sentry.captureMessage(exceptionString, {
    tags: { type: 'NativeException' },
    level: 'fatal',
  });
});

// Captura promesas rechazadas sin catch
Promise.prototype.catch = function(originalCatch) {
  return function(error: Error) {
    Sentry.captureException(error, {
      tags: { type: 'UnhandledPromise' },
    });
    return originalCatch.call(this, error);
  };
}(Promise.prototype.catch);
```

**üß© Ejemplo pr√°ctico con breadcrumbs:**

```tsx
const handleUpdateProfile = async (user: User) => {
  // Registra la intenci√≥n del usuario
  Sentry.addBreadcrumb({
    category: 'user.action',
    message: 'Usuario intenta actualizar perfil',
    level: 'info',
    data: { userId: user.id },
  });

  try {
    await api.updateProfile(user);
    
    Sentry.addBreadcrumb({
      category: 'api.success',
      message: 'Perfil actualizado exitosamente',
      level: 'info',
    });
    
    Alert.alert('‚úÖ Perfil actualizado');
  } catch (error) {
    Sentry.captureException(error, {
      tags: { section: 'ProfileUpdate' },
      extra: { userId: user.id, email: user.email },
    });

    Alert.alert('‚ùå Error al actualizar tu perfil. Int√©ntalo de nuevo.');
  }
};
```

**‚úÖ Mejores pr√°cticas:**
- Diferencia entre errores recuperables (muestra un fallback) y cr√≠ticos (reporta y det√©n)
- A√±ade contexto del usuario y acci√≥n previa con breadcrumbs
- Usa tags para agrupar errores por feature o secci√≥n

---

## 3Ô∏è‚É£ Versionado y seguimiento de builds

### üìñ Por qu√© importa

Imagina que un usuario reporta un bug y t√∫ no sabes qu√© versi√≥n de la app est√° usando. Es como buscar una aguja en un pajar. Cada build debe tener un identificador √∫nico visible para que QA, soporte o usuarios puedan reportar problemas con precisi√≥n.

### üîß C√≥mo implementarlo

Cada build debe tener un identificador √∫nico visible en pantalla (vista de perfil o "about").

**Instalaci√≥n:**
```bash
npm install expo-application
# O si no usas Expo:
npm install react-native-device-info
```

**Pantalla de informaci√≥n de la app:**

```tsx
import * as Application from 'expo-application';
import { Text, View, TouchableOpacity } from 'react-native';

const AboutScreen = () => {
  const version = Application.nativeApplicationVersion;
  const buildNumber = Application.nativeBuildVersion;
  
  return (
    <View style={{ padding: 20 }}>
      <Text style={{ fontSize: 16, marginBottom: 10 }}>
        Versi√≥n: {version} ({buildNumber})
      </Text>
      
      {/* Permite copiar la info para reportar */}
      <TouchableOpacity onPress={() => Clipboard.setString(`${version}-${buildNumber}`)}>
        <Text>üìã Copiar informaci√≥n de versi√≥n</Text>
      </TouchableOpacity>
    </View>
  );
};
```

**Integra con Sentry para contexto autom√°tico:**

```tsx
// En tu archivo de inicializaci√≥n (index.js o App.tsx)
import * as Application from 'expo-application';

Sentry.setContext('app', {
  version: Application.nativeApplicationVersion,
  build: Application.nativeBuildVersion,
  deviceModel: Device.modelName,
  osVersion: Device.osVersion,
});
```

**‚úÖ Mejores pr√°cticas:**
- Muestra versi√≥n + build number en formato legible (ej: "1.2.3 (456)")
- Permite copiar al portapapeles con un tap
- Incluye fecha del build si es posible
- Aseg√∫rate que est√© visible en m√∫ltiples pantallas

---

## 4Ô∏è‚É£ Feature flags activas y rollback r√°pido

### üìñ Por qu√© importa

¬øTe imaginas poder desactivar una feature problem√°tica sin tener que esperar d√≠as a que las stores aprueben un nuevo build? Los feature flags te dan ese superpoder. Nunca lances una feature directamente a todos los usuarios: configura flags que te permitan activar o desactivar funciones sin publicar una nueva versi√≥n.

### üîß C√≥mo implementarlo

Configura **feature flags** con **ConfigCat**, **LaunchDarkly** o tu propio backend.

**Ejemplo con ConfigCat:**

```bash
npm install configcat-react-native
```

```tsx
import { withConfigCatProvider, useFeatureFlag } from 'configcat-react-native';

const configCatKey = 'TU_CONFIGCAT_KEY';

// Envuelve tu App
export default withConfigCatProvider(App, configCatKey);

// Usa en cualquier componente
const MyComponent = () => {
  const { value: newFeatureEnabled, loading } = useFeatureFlag('NEW_FEATURE', false);
  
  if (loading) return <Loading />;
  
  return (
    <>
      {newFeatureEnabled ? (
        <NewFeatureUI />
      ) : (
        <OldFeatureUI />
      )}
    </>
  );
};
```

**Implementaci√≥n sencilla sin servicios externos:**

```tsx
// services/FeatureFlags.ts
class FeatureFlagService {
  private flags: Record<string, boolean> = {};
  
  async fetchFlags() {
    try {
      const response = await fetch('https://tu-api.com/feature-flags');
      const data = await response.json();
      this.flags = data;
    } catch (error) {
      console.error('Error fetching flags:', error);
      // Usa valores por defecto en caso de error
    }
  }
  
  isEnabled(flag: string): boolean {
    return this.flags[flag] ?? false;
  }
  
  async updateFlag(flag: string, enabled: boolean) {
    this.flags[flag] = enabled;
  }
}

export const featureFlags = new FeatureFlagService();

// Uso en componentes
const { isEnabled } = featureFlags;

if (isEnabled('SHOW_CHECKOUT_V2')) {
  return <CheckoutV2 />;
}
```

**‚úÖ Mejores pr√°cticas:**
- Implementa valores por defecto (fallback) si el servicio de flags falla
- Versiona tus flags para mantener compatibilidad
- Monitorea el uso de cada flag para decidir cu√°ndo remover c√≥digo legacy
- Considera flags por usuario o porcentaje de rollout

---

## 5Ô∏è‚É£ Logs con contexto

### üìñ Por qu√© importa

Ya implementaste `addBreadcrumb()` en funciones cr√≠ticas. Ahora escal√©moslo: crea un sistema de logging centralizado que capture contexto en TODA la app, no solo en los puntos donde manualmente lo a√±ades.

"El bot√≥n de pago no funciona" no te dice nada. "El usuario toc√≥ el bot√≥n de pago despu√©s de 3 reintentos, Gmail abierto en background, iOS 15.2" s√≠.

Los logs sin contexto son como mapas sin puntos de referencia. Te dicen que algo fall√≥, pero no por qu√© ni c√≥mo llegaste ah√≠.

### üîß C√≥mo implementarlo

Captura logs √∫tiles, no ruido.

**Estructura un sistema de logging con niveles:**

```tsx
enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
}

class Logger {
  log(level: LogLevel, message: string, context?: Record<string, any>) {
    const timestamp = new Date().toISOString();
    
    // En desarrollo: consola
    if (__DEV__) {
      console.log(`[${level.toUpperCase()}] ${timestamp}:`, message, context);
    }
    
    // En producci√≥n: Sentry
    if (level === LogLevel.ERROR) {
      Sentry.captureMessage(message, {
        level: level as Sentry.Severity,
        extra: context,
      });
    } else {
      Sentry.addBreadcrumb({
        category: level,
        message,
        level: level as Sentry.Severity,
        data: context,
      });
    }
  }
  
  debug(message: string, context?: Record<string, any>) {
    this.log(LogLevel.DEBUG, message, context);
  }
  
  info(message: string, context?: Record<string, any>) {
    this.log(LogLevel.INFO, message, context);
  }
  
  error(message: string, context?: Record<string, any>) {
    this.log(LogLevel.ERROR, message, context);
  }
}

export const logger = new Logger();

// Uso en tu app
logger.info('Usuario inici√≥ checkout', {
  userId: user.id,
  cartItems: cart.items.length,
});

logger.debug('Llamada API iniciada', {
  endpoint: '/api/checkout',
  method: 'POST',
  payloadSize: JSON.stringify(payload).length,
});
```

**Captura contexto del usuario:**

```tsx
// Configura contexto del usuario al iniciar sesi√≥n
Sentry.setUser({
  id: user.id,
  email: user.email,
  username: user.username,
});

// A√±ade contexto global de la app
Sentry.setContext('device', {
  model: Device.modelName,
  osVersion: Device.osVersion,
  memory: Device.totalMemory,
  networkType: await getNetworkType(),
});

// Breadcrumbs para navegaci√≥n
const navigationBreadcrumb = (screenName: string) => {
  Sentry.addBreadcrumb({
    category: 'navigation',
    message: `User navigated to ${screenName}`,
    level: 'info',
  });
};
```

**‚úÖ Mejores pr√°cticas:**
- No loguees datos sensibles (contrase√±as, tokens, tarjetas)
- Usa niveles apropiados (debug para dev, error para producci√≥n cr√≠tica)
- Limpia logs antiguos para evitar acumulaci√≥n de memoria
- Incluye timestamps y trace IDs para debugging distribuido

---

## 6Ô∏è‚É£ Performance tracking real

### üìñ Por qu√© importa

Una app que funciona pero es lenta es una app rota desde la perspectiva del usuario. Mide lo que importa: tiempo de carga, latencia de red, JS thread y FPS. Si no mides, no puedes mejorar.

**Ejemplo:** Los usuarios abandonan si una pantalla tarda m√°s de 3 segundos en cargar. Rastrear m√©tricas de performance te permite identificar cuellos de botella antes de que lleguen a producci√≥n.

### üîß C√≥mo implementarlo

Usa **Flipper**, **Sentry Performance** o **React Native Performance Monitor**.

**Configuraci√≥n b√°sica con Sentry Performance:**

```tsx
import * as Sentry from '@sentry/react-native';

// Rastrea transacciones (pantallas, flujos)
const loadProfileTransaction = Sentry.startTransaction({
  name: 'LoadProfile',
  op: 'navigation',
});

// Rastrea spans (operaciones espec√≠ficas)
const fetchUserSpan = loadProfileTransaction.startChild({
  op: 'http.client',
  description: 'GET /api/user',
});

try {
  const user = await api.getUser();
  fetchUserSpan.setHttpStatus(200);
} catch (error) {
  fetchUserSpan.setHttpStatus(error.response?.status || 500);
  Sentry.captureException(error);
} finally {
  fetchUserSpan.finish();
  loadProfileTransaction.finish();
}
```

**Mide tiempo de carga de pantallas:**

```tsx
import { useEffect } from 'react';
import { InteractionManager } from 'react-native';

const useScreenLoadTime = (screenName: string) => {
  useEffect(() => {
    const startTime = performance.now();
    
    InteractionManager.runAfterInteractions(() => {
      const loadTime = performance.now() - startTime;
      
      Sentry.addBreadcrumb({
        category: 'performance',
        message: `${screenName} loaded in ${loadTime.toFixed(0)}ms`,
        data: { loadTime },
      });
      
      // Alerta si es demasiado lento
      if (loadTime > 3000) {
        Sentry.captureMessage(`Slow screen load: ${screenName}`, {
          level: 'warning',
          extra: { loadTime },
        });
      }
    });
  }, []);
};

// Uso en componente
const ProfileScreen = () => {
  useScreenLoadTime('ProfileScreen');
  // ... resto del componente
};
```

**Mide FPS (Frames Per Second):**

```tsx
// Para monitor de performance en tiempo real
import { useFPSMetrics } from 'react-native-performance-monitor';

const MyComponent = () => {
  const fps = useFPSMetrics();
  
  useEffect(() => {
    if (fps < 30) {
      Sentry.addBreadcrumb({
        category: 'performance',
        message: 'Low FPS detected',
        data: { fps },
      });
    }
  }, [fps]);
  
  return null; // Componente invisible
};
```

**‚úÖ Mejores pr√°cticas:**
- Apunta a un **TTI (Time To Interactive)** menor a 5 segundos en dispositivos medios
- Rastrea m√©tricas en dispositivos reales, no solo simuladores
- Configura alertas para degradaci√≥n de performance
- Mide antes y despu√©s de optimizaciones para validar impacto

---

## 7Ô∏è‚É£ Testing automatizado en CI/CD

### üìñ Por qu√© importa

En el art√≠culo anterior mencionamos "automatiza lo que te salva" con testing E2E y CI. Pero ¬øc√≥mo configurarlo realmente? Aqu√≠ est√° el setup completo.

Un bug detectado en CI cuesta 10 minutos de tu tiempo. El mismo bug en producci√≥n cuesta horas de debugging, stress del equipo, y p√©rdida de confianza de usuarios. Cada build debe pasar pruebas E2E, linting y type checking. Rompe el build si algo falla: es m√°s barato detener un error en CI que en producci√≥n.

### üîß C√≥mo implementarlo

Cada build debe pasar pruebas E2E (con **Detox** o **Maestro**), linting y type checking.

**Configuraci√≥n de CI/CD con GitHub Actions:**

```yaml
# .github/workflows/ci.yml
name: CI

on: [pull_request] #[push, pull_request] 

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Type check
        run: npm run type-check
      
      - name: Run unit tests
        run: npm run test

```

**Ejemplo de tests E2E con Detox:**

```tsx
// e2e/checkout.e2e.ts
describe('Checkout Flow', () => {
  beforeAll(async () => {
    await device.launchApp();
  });

  it('should complete checkout successfully', async () => {
    // Login
    await element(by.id('email-input')).typeText('test@example.com');
    await element(by.id('password-input')).typeText('password123');
    await element(by.id('login-button')).tap();

    // Add item to cart
    await element(by.id('product-card-0')).tap();
    await element(by.id('add-to-cart-button')).tap();

    // Go to checkout
    await element(by.id('cart-button')).tap();
    await element(by.id('checkout-button')).tap();

    // Complete checkout
    await element(by.id('pay-button')).tap();
    await expect(element(by.text('Order confirmed'))).toBeVisible();
  });
});
```

**‚úÖ Mejores pr√°cticas:**
- Prueba flujos cr√≠ticos (login, checkout, settings)
- Corre tests en m√∫ltiples dispositivos y versiones de OS
- Aseg√∫rate que el CI falle si alg√∫n test falla
- Mant√©n tests r√°pidos (< 10 minutos para conjunto completo)

---

## 8Ô∏è‚É£ Manejo de estados offline y errores de API

### üìñ Por qu√© importa

Ya hablamos de "dise√±ar para fallar gracefully". Ahora, el c√≥mo t√©cnico: implementa offline detection, automatic retry logic, y user-friendly error messages.

"Error 500" no dice nada al usuario; "Parece que tenemos problemas, int√©ntalo en unos minutos" s√≠. Los usuarios est√°n en metro, en √°reas con se√±al d√©bil, o con WiFi que se cae constantemente. Una app que maneja bien estos casos es una app que genera confianza.

### üîß C√≥mo implementarlo

**Implementa un estado de red global:**

```tsx
import NetInfo from '@react-native-community/netinfo';

const NetworkStatus = () => {
  const [isConnected, setIsConnected] = useState(true);

  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsConnected(state.isConnected);
      
      // Reporta cambios de conectividad
      Sentry.addBreadcrumb({
        category: 'network',
        message: state.isConnected ? 'Network connected' : 'Network disconnected',
        data: { connectionType: state.type },
      });
    });

    return () => unsubscribe();
  }, []);

  return { isConnected };
};

// Componente de UI offline
const OfflineBanner = () => {
  const { isConnected } = NetworkStatus();
  
  if (!isConnected) {
    return (
      <View style={styles.offlineBanner}>
        <Text>Sin conexi√≥n. Revisando...</Text>
      </View>
    );
  }
  
  return null;
};
```

**Implementa retry con exponential backoff:**

```tsx
const fetchWithRetry = async (
  url: string,
  options: RequestInit,
  maxRetries = 3
) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return response;
      }
      
      // Si es error 5xx, reintentar
      if (response.status >= 500 && i < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
        continue;
      }
      
      return response;
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
    }
  }
};

// Uso
try {
  const response = await fetchWithRetry('/api/checkout', {
    method: 'POST',
    body: JSON.stringify(cartData),
  });
} catch (error) {
  Alert.alert(
    'Error de conexi√≥n',
    'Parece que tenemos problemas. Por favor intenta de nuevo en unos momentos.',
    [{ text: 'Reintentar', onPress: retryCheckout }]
  );
}
```

**‚úÖ Mejores pr√°cticas:**
- Revisa patrones de *retry* y *circuit breakers*
- Cachea datos cr√≠ticos localmente para modo offline
- Muestra estados de carga claros ("Guardando...", "Sincronizando...")
- Distingue entre errores del usuario y errores recuperables del servidor

---

## 9Ô∏è‚É£ Seguridad y datos sensibles

### üìñ Por qu√© importa

Una brecha de seguridad puede destruir tu app en minutos. Aseg√∫rate de no exponer tokens ni credenciales. Valida certificados, usa almacenamiento seguro y configura correctamente HTTPS y App Transport Security.

### üîß C√≥mo implementarlo

**Almacenamiento seguro de tokens:**

```tsx
import * as Keychain from 'react-native-keychain';
import * as SecureStore from 'expo-secure-store';

// Guardar token
await Keychain.setGenericPassword('authToken', userToken, {
  service: 'myApp',
  accessControl: Keychain.ACCESS_CONTROL.BIOMETRY_ANY,
});

// Recuperar token
const credentials = await Keychain.getGenericPassword({ service: 'myApp' });
const token = credentials ? credentials.password : null;
```

**O con Expo:**

```tsx
await SecureStore.setItemAsync('authToken', token, {
  requireAuthentication: true,
});

const token = await SecureStore.getItemAsync('authToken');
```

**SSL Pinning para APIs cr√≠ticas:**

```tsx
import RNFetchBlob from 'rn-fetch-blob';

const response = await RNFetchBlob.config({
  trusty: true,
}).fetch('GET', 'https://api.example.com/data');

// En producci√≥n, usa certificados espec√≠ficos
```

**Ocultar datos sensibles de logs:**

```tsx
const sanitizeLogData = (data: any): any => {
  if (typeof data !== 'object') return data;
  
  const sensitiveKeys = ['password', 'token', 'ssn', 'creditCard'];
  const sanitized = { ...data };
  
  Object.keys(sanitized).forEach(key => {
    if (sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive))) {
      sanitized[key] = '***REDACTED***';
    }
  });
  
  return sanitized;
};

logger.info('Login attempt', sanitizeLogData({ email: user.email, password: user.password }));
// Logs: { email: 'user@example.com', password: '***REDACTED***' }
```

**‚úÖ Mejores pr√°cticas:**
- Usa `react-native-keychain` o `expo-secure-store` para guardar datos sensibles
- Nunca hardcodees secrets en el c√≥digo
- Implementa SSL pinning para APIs cr√≠ticas
- Revoca tokens cuando detectes actividad sospechosa
- Valida y sanitiza todos los inputs del usuario

---

## üîü Alertas y visibilidad en tiempo real

### üìñ Por qu√© importa

Ya definimos las m√©tricas de estabilidad que debemos trackear (del art√≠culo anterior). Ahora, automatizemos las alertas: tu app no deber√≠a depender del usuario para enterarte de un bug.

Configura alertas autom√°ticas (Slack, Discord o PagerDuty) cuando haya picos de errores o baja estabilidad. Un equipo maduro tiene visibilidad antes de que el problema escale. Las alertas proactivas te permiten reaccionar en minutos, no en horas.

### üîß C√≥mo implementarlo

**Configuraci√≥n de alertas en Sentry:**

```tsx
// En Sentry Dashboard, configura alertas:
// - Crash rate > 0.5%
// - Nuevos errores
// - Degradaci√≥n de performance

// En tu c√≥digo, trigger manual de alertas cr√≠ticas
if (criticalError) {
  Sentry.captureException(error, {
    tags: { severity: 'critical' },
    extra: { requiresImmediateAction: true },
  });
}
```

**Webhook a Slack:**

```tsx
const sendSlackAlert = async (message: string) => {
  await fetch('https://hooks.slack.com/services/YOUR/WEBHOOK/URL', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      text: message,
      channel: '#alerts',
    }),
  });
};

// En tu error handler
const errorHandler = (error: Error, isFatal: boolean) => {
  if (isFatal) {
    sendSlackAlert(`üö® Crash fatal detectado: ${error.message}`);
  }
};
```

**Dashboard de m√©tricas clave:**

```tsx
// Configura en tu servicio de monitoreo un dashboard con:
// 1. Crash rate (√∫ltimas 24h)
// 2. Error rate por release
// 3. Performance promedio (TTI, FPS)
// 4. Usuarios activos vs usuarios con errores
```

**‚úÖ Mejores pr√°cticas:**
- Configura alertas en Slack, Discord o PagerDuty
- Define umbrales claros (ej: > 1% crash rate = alerta)
- Incluye contexto √∫til en alertas (versi√≥n, dispositivo, stack trace)
- Revisa y ajusta alertas para evitar ruido excesivo
- Ten un runbook para responder a cada tipo de alerta

---

### üöÄ Checklist final

| Check | Estado |
|-------|--------|
| Crash rate < 0.5% | ‚úÖ |
| Error handler global | ‚úÖ |
| Feature flags implementadas | ‚úÖ |
| Logs con contexto | ‚úÖ |
| Tests automatizados | ‚úÖ |
| Offline y fallback UI | ‚úÖ |
| Seguridad b√°sica cubierta | ‚úÖ |
| Alertas en tiempo real | ‚úÖ |

---

### üß© De checklist a proceso rutinario

Los 5 fundamentos del art√≠culo anterior + estos 10 checks de implementaci√≥n = **Tu escudo de resiliencia completo**.

No hay app sin bugs, pero s√≠ **equipos con visibilidad y procesos s√≥lidos**.

**C√≥mo implementar ambos art√≠culos juntos:**

**Semana 1-2:** Fundamentos (del art√≠culo anterior)
- Instala Sentry y configura crash tracking (Check #1 de este art√≠culo)
- Implementa error handlers globales (Check #2)

**Semana 3-4:** Profundiza
- Configura versionado y build tracking (Check #3)
- Implementa feature flags b√°sicos (Check #4)

**Mes 2:** Automatizaci√≥n
- Agrega CI/CD con tests E2E (Check #7)
- Configura performance tracking (Check #6)

**Mes 3:** Madurez
- Implementa manejo offline robusto (Check #8)
- Revisa seguridad y alertas (Checks #9 y #10)

**Cada check es una inversi√≥n en resiliencia.** La estabilidad no es glamorosa, pero es lo que separa una app de un producto que perdura.

> üí° **Tip:** Comparte este checklist con tu equipo antes del pr√≥ximo release. Hagan una quick review juntos.

---

¬øTe gust√≥ este enfoque?  
üí¨ Cu√©ntame qu√© otros checks aplicas en tus proyectos o qu√© herramientas te han salvado en producci√≥n.
